package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"
)

func genDecoder(filename string) {
	buf := &bytes.Buffer{}

	p := func(fmtstr string, args ...interface{}) {
		fmt.Fprintf(buf, fmtstr+"\n", args...)
	}

	p("// Code generated by github.com/rj45/rj32/emurj/cmd/isagen. DO NOT EDIT.")
	p("")
	p("package rj32")
	p("")

	p("type Reg uint8")
	p("")
	p("const (")
	regNames := strings.Fields(abiNames)
	for i, name := range regNames {
		if i == 0 {
			p("\t%s Reg = iota", capitalize(name))
		} else {
			p("\t%s", capitalize(name))
		}
	}
	p(")")
	p("")
	p("var regNames = [...]string {")
	for _, name := range regNames {
		p("\t%s: %q,", capitalize(name), name)
	}
	p("}")
	p("")
	p("func (r Reg) String() { return regNames[r] }")
	p("")

	p("type Fmt uint8")
	p("")
	p("const (")
	for i, name := range fmtOrder {
		if i == 0 {
			p("\t%s Fmt = iota", name)
			continue
		}
		p("\t%s", name)
	}
	p(")")
	p("")
	p("var fmtNames = [...]string {")
	for _, name := range fmtOrder {
		p("\t%s: %q,", name, name)
	}
	p("}")
	p("")
	p("func (f Fmt) String() { return fmtNames[f] }")
	p("")

	p("type Opcode uint8")
	p("")
	p("const (")
	for quad := range opmap {
		for i, name := range opmap[quad] {
			if name == "" {
				continue
			}
			p("\t%s Opcode = 0b%03b_%03b", capitalize(name), quad, i)
		}
	}
	p(")")
	p("")
	p("var opcodeNames = [...]string {")
	for quad := range opmap {
		for _, name := range opmap[quad] {
			if name == "" {
				continue
			}
			p("\t%s: %q,", capitalize(name), name)
		}
	}
	p("}")
	p("")
	p("func (o Opcode) String() { return opcodeNames[o] }")
	p("")

	p("type Inst uint32")
	p("")

	p("func (i Inst) Fmt() Fmt {")
	for _, matcher := range opcodeFmtMatchers {
		if matcher.mask == 0 {
			p("\treturn %s", matcher.fmt)
			continue
		}

		p("\tif (i & 0b%06b) == 0b%06b {", matcher.mask, matcher.match)
		p("\t\treturn %s", matcher.fmt)
		p("\t}")
	}
	p("}")
	p("")

	for _, name := range operandNames {
		if _, found := fieldBits[name]; !found {
			continue
		}

		p("func (i Inst) %s() %s {", capitalize(name), goOperandTypes[name])
		mask := (1 << ((fieldBits[name][0] - fieldBits[name][1]) + 1)) - 1
		p("\treturn (i >> %d) & 0b%b", fieldBits[name][1], mask)
		p("}")
		p("")
	}

	p("func (i Inst) Imm() %s {", goOperandTypes["imm"])
	for _, fmtName := range fmtOrder {
		if _, found := immBits[fmtName]; !found {
			continue
		}
		var matcher opcodeMatcher
		for _, m := range opcodeFmtMatchers {
			if m.fmt == fmtName {
				matcher = m
			}
		}
		bits := immBits[fmtName]

		p("\tif (i & 0b%06b) == 0b%06b { // %s fmt", matcher.mask, matcher.match, fmtName)
		bitstr := ""
		max := 0
		for _, field := range fmtFields[fmtName] {
			if _, found := bits[field]; !found {
				continue
			}
			imbits := bits[field]
			inbits := fieldBits[field]
			mask := (1 << ((inbits[0] - inbits[1]) + 1)) - 1
			p("\t\t%s := (i >> %d) & 0b%b", field, inbits[1], mask)
			_ = imbits
			if bitstr != "" {
				bitstr += " | "
			}
			if (imbits[0] - imbits[1]) != (inbits[0] - inbits[1]) {
				mask := (1 << ((imbits[0] - imbits[1]) + 1)) - 1
				bitstr += fmt.Sprintf("(%s & 0b%b) << %d", field, mask, imbits[1])
			} else {
				bitstr += fmt.Sprintf("%s << %d", field, imbits[1])
			}
			if imbits[0] > max {
				max = imbits[0]
			}
		}
		if max == 31 {
			p("\t\treturn %s", bitstr)
		} else {
			p("\t\treturn ((%s) << %d) >> %d", bitstr, 31-max, 31-max)
		}
		p("\t}")
	}
	p("\treturn 0")
	p("}")
	p("")

	fmted, err := format.Source(buf.Bytes())
	if err != nil {
		os.WriteFile(filename, buf.Bytes(), 0777)
		panic(err)
	}
	err = os.WriteFile(filename, fmted, 0777)
	if err != nil {
		panic(err)
	}
}

func capitalize(str string) string {
	return strings.ReplaceAll(strings.Title(str), ".", "")
}
